{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Expressive Authentication Middleware zend-expressive-authentication provides middleware for Expressive and PSR-7 applications for the purpose of authenticating HTTP requests using consumer- or third-party-provided adapters. Installation You can install the zend-expressive-authentication library with composer: $ composer require zendframework/zend-expressive-authentication Documentation Documentation is in the doc tree , and can be compiled using mkdocs : $ mkdocs build You may also browse the documentation online .","title":"Expressive Authentication Middleware"},{"location":"#expressive-authentication-middleware","text":"zend-expressive-authentication provides middleware for Expressive and PSR-7 applications for the purpose of authenticating HTTP requests using consumer- or third-party-provided adapters.","title":"Expressive Authentication Middleware"},{"location":"#installation","text":"You can install the zend-expressive-authentication library with composer: $ composer require zendframework/zend-expressive-authentication","title":"Installation"},{"location":"#documentation","text":"Documentation is in the doc tree , and can be compiled using mkdocs : $ mkdocs build You may also browse the documentation online .","title":"Documentation"},{"location":"v1/auth-adapter/","text":"Authentication adapters The authentication adapters for zend-expressive-authentication implement the interface Zend\\Expressive\\Authentication\\AuthenticationInterface : namespace Zend\\Expressive\\Authentication; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Message\\ResponseInterface; interface AuthenticationInterface { /** * Authenticate the PSR-7 request and return a valid user, * or null if not authenticated * * @param ServerRequestInterface $request * @return UserInterface|null */ public function authenticate(ServerRequestInterface $request): ?UserInterface; /** * Generate the unauthorized response * * @param ServerRequestInterface $request * @return ResponseInterface */ public function unauthorizedResponse(ServerRequestInterface $request): ResponseInterface; } This interface contains two method: authenticate() to check if a PSR-7 request contains a valid credential, and unauthorizedResponse() to generate and return an unauthorized response. We provide 4 authentication adapters: zend-expressive-authentication-basic , for Basic Access Authentication , supporting only bcrypt as the password hashing algorithm to ensure best security. zend-expressive-authentication-session , for authenticating username/password credential pairs and persisting them between requests via PHP sessions. zend-expressive-authentication-zendauthentication , supporting the zend-authentication component. zend-expressive-authentication-oauth2 , supporting the OAuth2 authentication framework via the league/oauth2-server package.","title":"Authentication adapter"},{"location":"v1/auth-adapter/#authentication-adapters","text":"The authentication adapters for zend-expressive-authentication implement the interface Zend\\Expressive\\Authentication\\AuthenticationInterface : namespace Zend\\Expressive\\Authentication; use Psr\\Http\\Message\\ServerRequestInterface; use Psr\\Http\\Message\\ResponseInterface; interface AuthenticationInterface { /** * Authenticate the PSR-7 request and return a valid user, * or null if not authenticated * * @param ServerRequestInterface $request * @return UserInterface|null */ public function authenticate(ServerRequestInterface $request): ?UserInterface; /** * Generate the unauthorized response * * @param ServerRequestInterface $request * @return ResponseInterface */ public function unauthorizedResponse(ServerRequestInterface $request): ResponseInterface; } This interface contains two method: authenticate() to check if a PSR-7 request contains a valid credential, and unauthorizedResponse() to generate and return an unauthorized response. We provide 4 authentication adapters: zend-expressive-authentication-basic , for Basic Access Authentication , supporting only bcrypt as the password hashing algorithm to ensure best security. zend-expressive-authentication-session , for authenticating username/password credential pairs and persisting them between requests via PHP sessions. zend-expressive-authentication-zendauthentication , supporting the zend-authentication component. zend-expressive-authentication-oauth2 , supporting the OAuth2 authentication framework via the league/oauth2-server package.","title":"Authentication adapters"},{"location":"v1/intro/","text":"Zend Expressive Authentication This component provides authentication abstraction using a middleware approach for PSR-7 and PSR-15 applications. Authentication is performed using the AuthenticationMiddleware class. This middleware consumes an AuthenticationInterface adapter to check if a PSR-7 request is authenticated or not. If authenticated, the middleware executes the next middleware in the application, passing a UserInterface object via a request attribute. If the request is not authenticated, the middleware returns a 401 Unauthorized response based on the authentication adapter provided. The Zend\\Expressive\\Authentication\\UserInterface is defined as follows: namespace Zend\\Expressive\\Authentication; interface UserInterface { /** * Get the unique user identity (id, username, email address, etc.). */ public function getIdentity() : string; /** * Get all user roles. * * @return string[] */ public function getRoles() : array; /** * Get the detail named $name if present; return $default otherwise. */ public function getDetail(string $name, $default = null); /** * Get all additional user details, if any. */ public function getDetails() : array; } The UserInterface attribute in the PSR-7 request can be used for checking if a user has been authenticated or not, e.g. it can be used to verify the authorization level of a user (for this scope, it is consumed by zend-expressive-authorization ). Default User class We provide a default implementation of UserInterface via the class Zend\\Expressive\\Authentication\\DefaultUser . The class is final and immutable, in order to prevent runtime changes. Repositories will fetch user information based on the identity, including any associated roles, and optionally any additional details (full name, email, profile information, etc.). Often, user data and the objects representing them are unique to the application. As such, the default repository implementations we provide allow you to inject a factory for producing the user. This factory should be a PHP callable with the following signature: function (string $identity, array $roles = [], array $details = []) : UserInterface In order to notify the package to use your custom factory, you will need to create a service factory that returns it, and map it to the Zend\\Expressive\\Authentication\\UserInterface service. We provide a service factory named Zend\\Expressive\\Authentication\\DefaultUserFactory that returns a user factory that produces a DefaultUser instance from the arguments provided. This is mapped as follows in the service configuration: use Zend\\Expressive\\Authentication\\DefaultUserFactory; use Zend\\Expressive\\Authentication\\UserInterface; return [ // ... 'dependencies' => [ 'factories' => [ // ... // Change the DefaultUserFactory::class with your custom service // factory that produces a user factory: UserInterface::class => DefaultUserFactory::class ] ] ]; Usage in the route The AuthenticationMiddleware can be used to authenticate a route. You just need to add the class name of the middleware in the pipeline of a route. As an example: $app->get('/admin/dashboard', [ Zend\\Expressive\\Authentication\\AuthenticationMiddleware::class, Admin\\Action\\Dashboard::class ], 'admin.dashboard'); In this example, the AuthenticationMiddleware is executed as first middleware of the route admin.dashboard . If the user is authenticated, the application executes the Dashboard action; otherwise it returns a 401 Unauthorized response. Choosing an authentication adapter You can choose an authentication adapter and a user repository through the service container configuration. You need to specify the service for authentication using the name Zend\\Expressive\\Authentication\\AuthenticationInterface and the user registry using the service name Zend\\Expressive\\Authentication\\UserRepositoryInterface::class . For instance, using zend-servicemanager you can easily configure these two services using aliases . Below is an example of configuration using the HTTP Basic Access Authentication adapter and the htpasswd file as the user repository. use Zend\\Expressive\\Authentication\\AuthenticationInterface; use Zend\\Expressive\\Authentication\\Basic; use Zend\\Expressive\\Authentication\\UserRepository; use Zend\\Expressive\\Authentication\\UserRepositoryInterface; return [ // ... 'dependencies' => [ // ... 'aliases' => [ // ... AuthenticationInterface::class => Basic\\BasicAccess::class, UserRepositoryInterface::class => UserRepository\\Htpasswd::class ] ] ];","title":"Introduction"},{"location":"v1/intro/#zend-expressive-authentication","text":"This component provides authentication abstraction using a middleware approach for PSR-7 and PSR-15 applications. Authentication is performed using the AuthenticationMiddleware class. This middleware consumes an AuthenticationInterface adapter to check if a PSR-7 request is authenticated or not. If authenticated, the middleware executes the next middleware in the application, passing a UserInterface object via a request attribute. If the request is not authenticated, the middleware returns a 401 Unauthorized response based on the authentication adapter provided. The Zend\\Expressive\\Authentication\\UserInterface is defined as follows: namespace Zend\\Expressive\\Authentication; interface UserInterface { /** * Get the unique user identity (id, username, email address, etc.). */ public function getIdentity() : string; /** * Get all user roles. * * @return string[] */ public function getRoles() : array; /** * Get the detail named $name if present; return $default otherwise. */ public function getDetail(string $name, $default = null); /** * Get all additional user details, if any. */ public function getDetails() : array; } The UserInterface attribute in the PSR-7 request can be used for checking if a user has been authenticated or not, e.g. it can be used to verify the authorization level of a user (for this scope, it is consumed by zend-expressive-authorization ).","title":"Zend Expressive Authentication"},{"location":"v1/intro/#default-user-class","text":"We provide a default implementation of UserInterface via the class Zend\\Expressive\\Authentication\\DefaultUser . The class is final and immutable, in order to prevent runtime changes. Repositories will fetch user information based on the identity, including any associated roles, and optionally any additional details (full name, email, profile information, etc.). Often, user data and the objects representing them are unique to the application. As such, the default repository implementations we provide allow you to inject a factory for producing the user. This factory should be a PHP callable with the following signature: function (string $identity, array $roles = [], array $details = []) : UserInterface In order to notify the package to use your custom factory, you will need to create a service factory that returns it, and map it to the Zend\\Expressive\\Authentication\\UserInterface service. We provide a service factory named Zend\\Expressive\\Authentication\\DefaultUserFactory that returns a user factory that produces a DefaultUser instance from the arguments provided. This is mapped as follows in the service configuration: use Zend\\Expressive\\Authentication\\DefaultUserFactory; use Zend\\Expressive\\Authentication\\UserInterface; return [ // ... 'dependencies' => [ 'factories' => [ // ... // Change the DefaultUserFactory::class with your custom service // factory that produces a user factory: UserInterface::class => DefaultUserFactory::class ] ] ];","title":"Default User class"},{"location":"v1/intro/#usage-in-the-route","text":"The AuthenticationMiddleware can be used to authenticate a route. You just need to add the class name of the middleware in the pipeline of a route. As an example: $app->get('/admin/dashboard', [ Zend\\Expressive\\Authentication\\AuthenticationMiddleware::class, Admin\\Action\\Dashboard::class ], 'admin.dashboard'); In this example, the AuthenticationMiddleware is executed as first middleware of the route admin.dashboard . If the user is authenticated, the application executes the Dashboard action; otherwise it returns a 401 Unauthorized response.","title":"Usage in the route"},{"location":"v1/intro/#choosing-an-authentication-adapter","text":"You can choose an authentication adapter and a user repository through the service container configuration. You need to specify the service for authentication using the name Zend\\Expressive\\Authentication\\AuthenticationInterface and the user registry using the service name Zend\\Expressive\\Authentication\\UserRepositoryInterface::class . For instance, using zend-servicemanager you can easily configure these two services using aliases . Below is an example of configuration using the HTTP Basic Access Authentication adapter and the htpasswd file as the user repository. use Zend\\Expressive\\Authentication\\AuthenticationInterface; use Zend\\Expressive\\Authentication\\Basic; use Zend\\Expressive\\Authentication\\UserRepository; use Zend\\Expressive\\Authentication\\UserRepositoryInterface; return [ // ... 'dependencies' => [ // ... 'aliases' => [ // ... AuthenticationInterface::class => Basic\\BasicAccess::class, UserRepositoryInterface::class => UserRepository\\Htpasswd::class ] ] ];","title":"Choosing an authentication adapter"},{"location":"v1/user-repository/","text":"User Repository An authentication adapter can pull user information from a variety of repositories: an htpasswd file a database a cache zend-expressive-authentication provides an interface, Zend\\Expressive\\Authentication\\UserRepositoryInterface , to access this user storage: namespace Zend\\Expressive\\Authentication; interface UserRepositoryInterface { /** * Authenticate the credential (username) using a password * or using only the credential string (e.g. token based credential) * It returns the authenticated user or null. * * @param string $credential can be also a token */ public function authenticate(string $credential, string $password = null) : ?UserInterface; } It contains only the authenticate() function, to authenticate the user's credential. If authenticated, the result will be a UserInterface instance; otherwise, a null value is returned. Configure the user repository In order to use a user repository adapter, we need to configure it. For instance, to consume an htpasswd file, we need to configure the path to the file. Such configuration is provided in the authentication hierarchy provided to your PSR-11 container. We demonstrate examples of such configuration below. Using Expressive , this configuration can be stored in a file under the /config/autoload/ folder. We suggest to use a .local.php suffix \u2014 e.g. /config/autoload/auth.local.php \u2014 as local configuration is not stored in the version control system. You can also provide this configuration using a ConfigProvider.php class. Read this blog post for more information on config providers. htpasswd configuration When using the htpasswd user repository implementation, you need only configure the path to the htpasswd file and a realm . The htpasswd file must use bcrypt hash algorithm: return [ 'authentication' => [ 'realm' => 'insert realm value', 'htpasswd' => 'insert the path to htpasswd file', ], ]; PDO configuration When using the PDO user repository adapter, you will need to provide PDO connection parameters, as well as information on the table, field names, and a SQL statement for retrieving user roles: return [ 'authentication' => [ 'pdo' => [ 'dsn' => '', 'username' => '', 'password' => '', 'table' => 'user table name', 'field' => [ 'identity' => 'identity field name', 'password' => 'password field name', ], 'sql_get_roles' => 'SQL to retrieve roles with :identity parameter', 'sql_get_details' => 'SQL to retrieve user details by :identity', ], ], ]; The required parameters are dsn , table , and field . The dsn value is the DSN connection string to be used to connect to the database. For instance, using a SQLite database, a typical value is sqlite:/path/to/file . The username and password parameters are optional parameters used to connect to the database. Depending on the database, these parameters may not be required; e.g. SQLite does not require them. The table value is the name of the table containing the user credentials. The field parameter contains the field name of the identity of the user and the user password. The identity of the user can be a username, an email, etc. The sql_get_roles setting is an optional parameter that contains the SQL query for retrieving the user roles. The identity value must be specified using the placeholder :identity . For instance, if a role is stored in a user table, a typical query might look like the following: SELECT role FROM user WHERE username = :identity The sql_get_details parameter is similar to sql_get_roles : it specifies the SQL query for retrieving the user's additional details, if any. For instance, if a user has an email field this can be returned as additional detail using the following query: SELECT email FROM user WHERE username = :identity PDO service name Since 1.1.0 As an alternative, you can provide a service name instead of PDO connection parameters. In such a case, you can substitute the key service for the dsn configuration key: return [ 'authentication' => [ 'pdo' => [ 'service' => \\PDO::class, // \"service\" instead of \"dsn\" 'table' => 'user table name', 'field' => [ 'identity' => 'identity field name', 'password' => 'password field name', ], 'sql_get_roles' => 'SQL to retrieve roles with :identity parameter', 'sql_get_details' => 'SQL to retrieve user details by :identity', ], ], ]; The parameters table and field still remain required, and one or the other of dsn or service MUST be present. When specifying the service key, the value MUST evaluate to an existing service that resolves to a PDO instance.","title":"User repository"},{"location":"v1/user-repository/#user-repository","text":"An authentication adapter can pull user information from a variety of repositories: an htpasswd file a database a cache zend-expressive-authentication provides an interface, Zend\\Expressive\\Authentication\\UserRepositoryInterface , to access this user storage: namespace Zend\\Expressive\\Authentication; interface UserRepositoryInterface { /** * Authenticate the credential (username) using a password * or using only the credential string (e.g. token based credential) * It returns the authenticated user or null. * * @param string $credential can be also a token */ public function authenticate(string $credential, string $password = null) : ?UserInterface; } It contains only the authenticate() function, to authenticate the user's credential. If authenticated, the result will be a UserInterface instance; otherwise, a null value is returned.","title":"User Repository"},{"location":"v1/user-repository/#configure-the-user-repository","text":"In order to use a user repository adapter, we need to configure it. For instance, to consume an htpasswd file, we need to configure the path to the file. Such configuration is provided in the authentication hierarchy provided to your PSR-11 container. We demonstrate examples of such configuration below. Using Expressive , this configuration can be stored in a file under the /config/autoload/ folder. We suggest to use a .local.php suffix \u2014 e.g. /config/autoload/auth.local.php \u2014 as local configuration is not stored in the version control system. You can also provide this configuration using a ConfigProvider.php class. Read this blog post for more information on config providers.","title":"Configure the user repository"},{"location":"v1/user-repository/#htpasswd-configuration","text":"When using the htpasswd user repository implementation, you need only configure the path to the htpasswd file and a realm . The htpasswd file must use bcrypt hash algorithm: return [ 'authentication' => [ 'realm' => 'insert realm value', 'htpasswd' => 'insert the path to htpasswd file', ], ];","title":"htpasswd configuration"},{"location":"v1/user-repository/#pdo-configuration","text":"When using the PDO user repository adapter, you will need to provide PDO connection parameters, as well as information on the table, field names, and a SQL statement for retrieving user roles: return [ 'authentication' => [ 'pdo' => [ 'dsn' => '', 'username' => '', 'password' => '', 'table' => 'user table name', 'field' => [ 'identity' => 'identity field name', 'password' => 'password field name', ], 'sql_get_roles' => 'SQL to retrieve roles with :identity parameter', 'sql_get_details' => 'SQL to retrieve user details by :identity', ], ], ]; The required parameters are dsn , table , and field . The dsn value is the DSN connection string to be used to connect to the database. For instance, using a SQLite database, a typical value is sqlite:/path/to/file . The username and password parameters are optional parameters used to connect to the database. Depending on the database, these parameters may not be required; e.g. SQLite does not require them. The table value is the name of the table containing the user credentials. The field parameter contains the field name of the identity of the user and the user password. The identity of the user can be a username, an email, etc. The sql_get_roles setting is an optional parameter that contains the SQL query for retrieving the user roles. The identity value must be specified using the placeholder :identity . For instance, if a role is stored in a user table, a typical query might look like the following: SELECT role FROM user WHERE username = :identity The sql_get_details parameter is similar to sql_get_roles : it specifies the SQL query for retrieving the user's additional details, if any. For instance, if a user has an email field this can be returned as additional detail using the following query: SELECT email FROM user WHERE username = :identity","title":"PDO configuration"},{"location":"v1/user-repository/#pdo-service-name","text":"Since 1.1.0 As an alternative, you can provide a service name instead of PDO connection parameters. In such a case, you can substitute the key service for the dsn configuration key: return [ 'authentication' => [ 'pdo' => [ 'service' => \\PDO::class, // \"service\" instead of \"dsn\" 'table' => 'user table name', 'field' => [ 'identity' => 'identity field name', 'password' => 'password field name', ], 'sql_get_roles' => 'SQL to retrieve roles with :identity parameter', 'sql_get_details' => 'SQL to retrieve user details by :identity', ], ], ]; The parameters table and field still remain required, and one or the other of dsn or service MUST be present. When specifying the service key, the value MUST evaluate to an existing service that resolves to a PDO instance.","title":"PDO service name"}]}